# Project Rule

This file provides guidance to LLM when working with code in this repository.

## Project Overview

iDO is an AI-powered desktop activity monitoring and task recommendation system built with Tauri 2.x. It uses a **three-layer architecture** (Perception -> Processing -> Consumption) to capture user activities, analyze them with LLM, and provide intelligent task recommendations. All processing happens locally for privacy.

**Tech Stack:**
- Frontend: React 19 + TypeScript 5 + Vite 6 + Tailwind CSS 4
- Backend: Python 3.14+ (PyTauri 0.8 for Tauri integration, FastAPI for development)
- Desktop: Tauri 2.x (Rust runtime)
- Database: SQLite (local)
- State: Zustand 5

## Development Commands

### Environment Setup

```bash
# Initial setup (macOS/Linux)
pnpm setup

# Initial setup (Windows)
pnpm setup:win

# Or manual setup
pnpm setup-all  # Installs frontend + backend dependencies
```

### Development

```bash
# Frontend only (React dev server at localhost:5173)
pnpm dev

# Full app with TypeScript client auto-generation (recommended)
pnpm tauri:dev:gen-ts

# Basic Tauri dev (no TS generation)
pnpm tauri dev

# Backend API server only (FastAPI at localhost:8000)
uvicorn app:app --reload
# or
uv run python app.py
```

### Code Quality

```bash
# Format code
pnpm format

# Check formatting
pnpm lint

# Validate i18n translations consistency
pnpm check-i18n

# Python type checking (ty / basedpyright)
uv run ty check

# Frontend TypeScript compilation check
pnpm tsc
```

> **Type checking requirements**
>
> - **Backend:** Always run `uv run ty check` before submitting backend changes.
>   - Prefer precise type hints (Protocols, `TypedDict`, etc.) over `Any`.
>   - Keep optional dependencies behind `import_module` guards so ty can resolve them.
>   - When ty reports "possibly-missing-attribute", either add a Protocol or guard the access; do not ignore the warning.
>
> - **Frontend:** Always run `pnpm tsc` before submitting frontend changes.
>   - Ensure all TypeScript files compile without errors.
>   - Fix all type errors before committing code.
>   - Do not use `@ts-ignore` or `any` types without justification.

### Build

```bash
# Production build
pnpm tauri build

# macOS with code signing
pnpm tauri:build:signed

# Platform-specific bundle
pnpm bundle        # macOS/Linux
pnpm bundle:win    # Windows

# Clean build artifacts
pnpm clean
```

## Architecture Overview

### Three-Layer Design

```
+------------------------------------------+
|   Consumption Layer                      |
|   AI analysis -> Task recommendations    |
|   * frontend views, agents               |
+------------------------------------------+
              ^
+------------------------------------------+
|   Processing Layer                       |
|   Event filtering -> LLM summary ->      |
|   Activity merging -> DB persistence     |
|   * backend/processing, backend/llm      |
+------------------------------------------+
              ^
+------------------------------------------+
|   Perception Layer                       |
|   Keyboard -> Mouse -> Screenshots       |
|   * backend/perception                   |
+------------------------------------------+
```

**Data Flow:** RawRecords (20s window) -> Events (filtered) -> Activities (aggregated) -> Tasks (AI-generated)

### Core Backend Components

**Coordinator** (`backend/core/coordinator.py`):
- Orchestrates PerceptionManager and ProcessingPipeline lifecycle
- Manages system state: running | stopped | requires_model | error | starting
- Tracks active LLM model and statistics

**API Handler System** (`backend/handlers/__init__.py`):
- `@api_handler` decorator: Write once, works in both PyTauri (desktop) and FastAPI (web)
- Auto-generates TypeScript clients with full type safety
- Auto-converts Python snake_case <-> JavaScript camelCase

**Event System** (`backend/core/events.py`):
- Backend emits Tauri events (e.g., `activity-created`, `activity-updated`)
- Frontend listens via `useTauriEvents` hook
- Enables real-time UI updates without polling

### Frontend Organization

**Views** (`src/views/`):
- Page-level components (Dashboard, Chat, Agents, Activity, Settings, etc.)
- Connected to Zustand stores

**Stores** (`src/lib/stores/`):
- `activity.ts`: Timeline data, incremental updates
- `agents.ts`: Task management
- `chat.ts`: AI chat interface
- `models.ts`: LLM model management
- `settings.ts`: User preferences
- `permissions.ts`: System permissions state

**Auto-generated Client** (`src/lib/client/`):
- TypeScript types and API client auto-generated from Python @api_handler functions
- Regenerated on `pnpm tauri:dev:gen-ts` or `pnpm setup-backend`

## Key Development Patterns

### Adding a New API Handler

```python
# backend/handlers/my_feature.py
from backend.handlers import api_handler
from backend.models.base import BaseModel

class MyRequest(BaseModel):
    user_input: str  # Python snake_case

@api_handler(
    body=MyRequest,
    method="POST",
    path="/my-endpoint",
    tags=["my-module"]
)
async def my_handler(body: MyRequest) -> dict:
    """My feature description"""
    return {"success": True, "data": body.user_input}
```

**Auto-registers as:**
- PyTauri command: `apiClient.myHandler({ userInput: "..." })`
- FastAPI endpoint: `POST /api/my-endpoint`

**Important:** After adding handlers:
1. Import in `backend/handlers/__init__.py`
2. Run `pnpm setup-backend` to sync
3. TypeScript types auto-generate in `src/lib/client/`

### Adding a New Agent

```python
# backend/agents/my_agent.py
from backend.agents.base import BaseAgent

class MyAgent(BaseAgent):
    async def can_handle(self, activity: Activity) -> bool:
        # Determine if this agent should process the activity
        return "coding" in activity.description.lower()

    async def execute(self, activity: Activity) -> Task:
        # Generate task recommendations
        return Task(title="...", description="...")

# Register in backend/agents/__init__.py
from .my_agent import MyAgent
AgentFactory.register(MyAgent())
```

### Adding i18n Translations

```typescript
// src/locales/en.ts
export const en = {
  myFeature: {
    title: "My Feature",
    description: "Feature description"
  }
}

// src/locales/zh-CN.ts
export const zhCN = {
  myFeature: {
    title: "My Feature Title in Chinese",
    description: "Feature description in Chinese"
  }
}

// Use in components
import { useTranslation } from 'react-i18next'
const { t } = useTranslation()
t('myFeature.title')
```

**Validate:** Run `pnpm check-i18n` to ensure all keys match across locales.

### Backend Module Import Pattern

The codebase supports both development and production environments:

```python
# Development: imports from backend/ in project root
# Production: imports from ido_backend/ (installed package)

# This is handled automatically in src-tauri/python/ido_app/__init__.py
# Always use: from backend.X import Y (not ido_backend)
```

When adding new Python modules to `backend/`, always run `pnpm setup-backend` to sync.

### TypeScript Client Generation

TypeScript types auto-generate when:
- Running `pnpm tauri:dev:gen-ts`
- Running `pnpm setup-backend`
- Environment variable `PYTAURI_GEN_TS=1` is set

**How it works:**
1. PyTauri analyzes Python @api_handler functions
2. Extracts Pydantic models and type hints
3. Runs `pnpm json2ts` to generate TypeScript interfaces
4. Outputs to `src/lib/client/`

### Emitting Events from Backend

```python
from backend.core.events import emit_event

# Emit event to frontend
await emit_event("activity-created", {"id": activity.id})
```

```typescript
// Frontend: Listen to events
import { useTauriEvents } from '@/hooks/useTauriEvents'

useTauriEvents({
  'activity-created': (payload) => {
    // Handle event
  }
})
```

### SQL Query Management

**All SQL queries must be placed in `backend/core/sqls/queries.py` for maintainability.**

```python
# backend/core/sqls/queries.py
SELECT_ACTIVITY_COUNT_BY_DATE = """
    SELECT
        DATE(start_time) as date,
        COUNT(*) as count
    FROM activities
    WHERE deleted = 0
    GROUP BY DATE(start_time)
    ORDER BY date DESC
"""

# backend/processing/persistence.py or backend/core/db.py
from core.sqls import queries

async def get_activity_count_by_date(self) -> List[Dict[str, Any]]:
    with self._get_conn() as conn:
        cursor = conn.execute(queries.SELECT_ACTIVITY_COUNT_BY_DATE)
        return [{"date": row["date"], "count": row["count"]} for row in cursor.fetchall()]
```

**Never inline SQL queries in persistence or handler methods.** This pattern:
- Centralizes all SQL for easy review and modification
- Makes schema changes easier to track
- Improves code organization and maintainability

### Creating Reusable UI Components

When creating timeline or list components with sticky headers:

```typescript
// Use StickyTimelineGroup for date-grouped data
import { StickyTimelineGroup } from '@/components/shared/StickyTimelineGroup'

<StickyTimelineGroup
  items={activities}
  getDate={(activity) => activity.startTimestamp}
  renderItem={(activity) => <ActivityCard activity={activity} />}
  dateCountMap={dateCountMap}  // Optional: pass real DB counts
  emptyMessage={t('activity.noData')}
/>
```

The component handles:
- Automatic date grouping and sorting
- Sticky headers that replace on scroll (CSS sticky positioning)
- i18n date formatting
- Optional real database counts vs loaded item counts

## Project Structure

```
ido/
├── src/                          # React frontend
│   ├── views/                   # Page components
│   ├── components/              # Reusable UI components
│   ├── lib/
│   │   ├── stores/              # Zustand state management
│   │   ├── client/              # Auto-generated PyTauri client
│   │   ├── types/               # TypeScript type definitions
│   │   └── config/              # Frontend config (menu, routes)
│   ├── hooks/                   # React hooks (useTauriEvents, etc.)
│   └── locales/                 # i18n translation files
│
├── backend/                      # Python backend (points to root)
│   ├── handlers/                # API handlers (@api_handler)
│   ├── core/                    # Core systems (coordinator, db, events)
│   ├── models/                  # Pydantic data models
│   ├── processing/              # Processing layer
│   ├── perception/              # Perception layer (keyboard, mouse, screenshots)
│   ├── agents/                  # AI task agents
│   ├── llm/                     # LLM client integration
│   └── config/                  # Backend configuration
│
├── src-tauri/                    # Tauri app
│   ├── python/ido_app/       # PyTauri entry point
│   ├── src/                     # Rust code
│   └── tauri.conf.json          # Tauri config
│
├── scripts/                      # Build and development scripts
│   ├── unix/                    # macOS/Linux scripts
│   ├── windows/                 # Windows PowerShell scripts
│   └── cross-platform/          # Platform-agnostic scripts
│
└── docs/                        # Detailed documentation
```

## Important Files

- `backend/handlers/__init__.py`: API handler registry, import all handler modules here
- `backend/core/coordinator.py`: Backend lifecycle coordinator
- `backend/core/events.py`: Tauri event emission system
- `backend/core/sqls/queries.py`: **All SQL queries must be defined here**
- `backend/core/sqls/schema.py`: Database table schemas
- `backend/core/db.py`: Old architecture database operations
- `backend/processing/persistence.py`: New architecture database operations
- `src-tauri/python/ido_app/__init__.py`: PyTauri entry point, registers commands
- `src/lib/client/`: Auto-generated TypeScript API client (DO NOT EDIT MANUALLY)
- `src/lib/stores/`: Zustand state stores
- `src/hooks/useTauriEvents.ts`: Tauri event listener hook
- `src/components/shared/`: Reusable UI components (StickyTimelineGroup, TimeDisplay, etc.)
- `pyproject.toml`: Python dependencies and build config
- `package.json`: Node.js dependencies and scripts

## Data Models

**Core Types:**
- `RawRecord`: Raw events from perception layer (20s sliding window)
- `Event`: Filtered events with LLM summaries
- `Activity`: User-visible activity aggregations
- `Task`: AI-generated task recommendations

All Pydantic models inherit from `backend/models/base.BaseModel` which provides automatic camelCase <-> snake_case conversion for frontend compatibility.

## Common Development Scenarios

### Scenario 1: Frontend-only changes

```bash
pnpm dev  # Fast dev server, no backend changes needed
```

### Scenario 2: Backend + Frontend changes

```bash
pnpm tauri:dev:gen-ts  # Hot reload, auto-generates TS types
```

### Scenario 3: Adding new Python handler

```bash
# 1. Create handler in backend/handlers/my_feature.py with @api_handler
# 2. Import in backend/handlers/__init__.py
# 3. Sync backend
pnpm setup-backend

# 4. Start dev
pnpm tauri:dev:gen-ts

# 5. Use in frontend (types auto-available)
import { apiClient } from '@/lib/client'
await apiClient.myHandler(...)
```

### Scenario 4: Debugging backend API independently

```bash
# Start FastAPI server (same handlers as PyTauri)
uvicorn app:app --reload

# Visit API docs: http://localhost:8000/docs
# Test endpoints in Swagger UI
```

## System Integration

### LLM Integration

- Backend uses OpenAI API (configurable in settings)
- Model configuration stored in SQLite
- Active model must pass test before system can run
- LLM used for: event summarization, activity analysis, task generation

### Database

- SQLite database at `~/.config/ido/ido.db`
- Tables: activities, events, tasks, llm_models, settings, etc.
- Database operations in `backend/core/db.py`

### System Permissions (macOS)

Requires permissions for:
- Accessibility (keyboard/mouse monitoring)
- Screen Recording (screenshots)
- Handled by `backend/handlers/permissions.py`

## Debugging Tips

- **TypeScript client not updating?** Run `pnpm setup-backend`
- **Backend changes not reflected?** Restart `pnpm tauri dev`
- **CamelCase conversion issues?** Ensure models inherit from `backend/models/base.BaseModel`
- **Event not emitting?** Check `backend/core/events.py` registered AppHandle
- **i18n key mismatch?** Run `pnpm check-i18n`

## Testing

```bash
# Backend tests (if available)
pytest

# Frontend linting
pnpm lint

# i18n validation
pnpm check-i18n
```

## Platform-Specific Notes

### macOS

- Code signing required for distribution: `pnpm tauri:build:signed`
- Uses `pyobjc` for native macOS APIs
- Scripts in `scripts/unix/`

### Windows

- Use PowerShell scripts: `pnpm setup:win`, `pnpm tauri:dev:gen-ts:win`
- Scripts in `scripts/windows/`
- May require execution policy adjustment

### Linux

- Use Unix scripts: `pnpm setup`, `pnpm tauri:dev:gen-ts`
- Requires X11 or Wayland for GUI

## Privacy & Security

- All data processing is local (no cloud uploads)
- Screenshots stored locally with automatic expiration
- LLM calls use user-provided API keys
- Database is local SQLite
- Open source and auditable
