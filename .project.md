# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Rewind is a Tauri-based desktop application that monitors and analyzes user activity (keyboard, mouse, screenshots) using AI to provide intelligent insights and task recommendations. It features a three-layer architecture:

1. **Perception Layer** - Captures raw user input (keyboard, mouse, screenshots)
2. **Processing Layer** - Filters, summarizes, and organizes events using LLM
3. **Consumption Layer** - Provides intelligent analysis and agent-based task execution

## Technology Stack

### Frontend

- **Framework**: React 19 + TypeScript 5
- **Build Tool**: Vite 6
- **Routing**: React Router 7
- **State Management**: Zustand 5 (with persist middleware)
- **UI Components**: shadcn/ui (Radix UI primitives)
- **Styling**: Tailwind CSS 4
- **Forms**: React Hook Form + Zod
- **Date Handling**: date-fns
- **Notifications**: Sonner

### Backend

- **Runtime**: Tauri 2.x (Rust)
- **Python Backend**: PyTauri 0.8 (Python ↔ Rust bridge)
- **Database**: SQLite
- **LLM Integration**: OpenAI API (configurable)
- **Image Processing**: OpenCV, PIL
- **System Monitoring**:
  - **Keyboard/Mouse**: Platform-specific implementations (factory pattern)
    - macOS: PyObjC NSEvent (keyboard), pynput (mouse)
    - Windows: pynput (extensible to Win32 API)
    - Linux: pynput (extensible to X11/evdev)
  - **Screenshots**: mss (cross-platform)

## Quick Command Reference

Essential commands for common development tasks:

```bash
# First time setup
pnpm setup                    # macOS/Linux - installs all dependencies
pnpm setup:win                # Windows - installs all dependencies
git config core.autocrlf false # Windows only - prevent line ending issues

# Development
pnpm dev                      # Frontend only (fastest, http://localhost:5173)
pnpm tauri:dev:gen-ts         # Full app + TS client generation (recommended)
uvicorn app:app --reload      # Backend API only (http://localhost:8000/docs)

# After Python changes
pnpm setup-backend            # Re-sync Python environment at project root
pnpm tauri dev                # Restart with new Python modules

# Quality checks
pnpm format                   # Format code (Prettier)
pnpm lint                     # Check formatting (CI validation)
pnpm check-i18n               # Validate translation consistency

# Build
pnpm tauri build              # Production build
pnpm clean                    # Clean build artifacts
```

## Development Commands

### Initial Setup

Run one of these commands from the project root to initialize everything:

```bash
# macOS / Linux (recommended)
pnpm setup

# Windows
pnpm setup:win

# Or manually run all steps
pnpm setup-all
```

This automatically:
1. Installs frontend dependencies (`pnpm install`)
2. Initializes Python environment (`uv sync` - creates `.venv` in project root)
3. Verifies i18n translations (`pnpm check-i18n`)

**Critical**: Python environment is at **project root**, not `src-tauri/`. The `pyproject.toml` is at the project root.

### Common Development Workflows

**Frontend-only development** (fastest iteration):
```bash
pnpm dev  # http://localhost:5173
```

**Full application development** (with backend):
```bash
pnpm tauri:dev:gen-ts  # Recommended - auto-generates TypeScript client
# OR
pnpm tauri dev  # Without regenerating client
```

**Backend API development** (standalone FastAPI):
```bash
uvicorn app:app --reload  # http://localhost:8000/docs
# OR
uv run python app.py
```

**After adding Python modules or dependencies**:
```bash
pnpm setup-backend  # Re-sync Python environment
pnpm tauri dev      # Regenerate TypeScript client
```

### Code Quality

```bash
pnpm format          # Format code (Prettier)
pnpm lint            # Check formatting (CI)
pnpm check-i18n      # Validate translation keys
pnpm build           # Build TypeScript and frontend
pnpm tauri build     # Build production app
pnpm clean           # Clean build artifacts
```

## Architecture Guidelines

### Three-Layer Backend Architecture

```
┌──────────────────────────────────────────────────────────┐
│              Consumption Layer (消费层)                  │
│              AI 分析 → 智能推荐 → Agent 执行            │
└──────────────────────────────────────────────────────────┘
                          ▲
┌──────────────────────────────────────────────────────────┐
│              Processing Layer (处理层)                   │
│       事件筛选 → LLM总结 → 活动合并 → 数据库存储        │
└──────────────────────────────────────────────────────────┘
                          ▲
┌──────────────────────────────────────────────────────────┐
│              Perception Layer (感知层)                   │
│         键盘监控 → 鼠标监控 → 屏幕截图采集              │
└──────────────────────────────────────────────────────────┘
```

**Data Flow:**
```
Raw Records (20s sliding window)
    ↓ [Every 10s]
Events (with events_summary)
    ↓ [LLM summarization + activity merging]
Activity (persisted to SQLite)
    ↓ [Intelligent analysis]
Agent Tasks → TODO
```

### Frontend Architecture

**Component Hierarchy:**
```
Pages (src/views/)                    # Data fetching, state management
  ├─ Containers (src/components/)     # Business logic, composition
  │   └─ Components                   # Pure presentation
  │       └─ Primitives (shadcn-ui)   # Base UI components
```

**State Management Strategy:**
- **Zustand Stores** (`src/lib/stores/`) for cross-component state
  - `activity.ts` - Timeline data and filters
  - `agents.ts` - Agent tasks and execution state
  - `chat.ts` - Chat conversation state
  - `dashboard.ts` - Metrics and statistics
  - `insights.ts` - AI insights data
  - `models.ts` - LLM model configuration
  - `settings.ts` - Application settings
  - `ui.ts` - UI state (sidebar, menu selection)
  - `user.ts` - User profile and preferences
- **Props/Callbacks** for parent-child communication
- **Context** for theme and global configuration
- **Tauri Events** for backend → frontend real-time updates

**Communication Pattern:**
```
User Action → Component Handler → Zustand Action → Service Layer → PyTauri Client → Backend
                                                                                      ↓
Frontend Component ← Zustand Store Update ← Response/Tauri Event ←←←←←←←←←←←←←←←←←←←←←
```

### Universal API Handler System

The project uses a **universal `@api_handler` decorator** that automatically registers backend functions for **both PyTauri and FastAPI** frameworks.

**Adding a New API Handler:**

1. Create handler in `backend/handlers/my_module.py`:
   ```python
   from . import api_handler
   from models import MyRequest

   @api_handler(
       body=MyRequest,           # Pydantic model (optional if no params)
       method="POST",            # HTTP method (for FastAPI)
       path="/my-endpoint",      # Custom path (for FastAPI)
       tags=["my-module"]        # API tags (for FastAPI docs)
   )
   async def my_handler(body: MyRequest) -> dict:
       """Handler description (auto-converted to API docs)"""
       return {"success": True, "data": body.field1}
   ```

2. Add Request Model in `backend/models/requests.py`:
   ```python
   from .base import BaseModel

   class MyRequest(BaseModel):
       """Request model inherits camelCase conversion"""
       field1: str
       field2: int = 100  # With default
   ```

3. Import module in `backend/handlers/__init__.py`:
   ```python
   from . import greeting, perception, processing, my_module
   ```

4. Regenerate TypeScript client and test:
   ```bash
   pnpm tauri:dev:gen-ts
   ```

**Key Features:**
- **Single Definition**: Works for both PyTauri (desktop) and FastAPI (web API)
- **Auto-Registration**: No manual command registration needed
- **Type Safety**: Pydantic models auto-generate TypeScript types
- **CamelCase Conversion**: Python `snake_case` ↔ JavaScript `camelCase` automatic
- **API Documentation**: FastAPI auto-generates OpenAPI/Swagger docs at `/docs`

**Critical Constraint**: PyTauri handlers MUST use a single `body` parameter with a Pydantic model. Direct parameters like `def handler(name: str)` will fail.

## Key Design Patterns

### 1. Configuration-Driven Menu

Menu items in `src/lib/config/menu.ts` drive both routing and sidebar UI:
- Supports position grouping (main/bottom)
- Badge notifications
- Dynamic visibility control

### 2. PyTauri Client Auto-Generation

- Backend changes trigger automatic TypeScript client generation
- Located in `src/lib/client/` (marked as auto-generated)
- **Never manually edit client files**

### 3. Service Layer Pattern

Services in `src/lib/services/` wrap PyTauri client calls:
- Handles error logging and retry logic
- Used by Zustand store actions
- Provides clean API abstraction

### 4. Store Subscription Optimization

```typescript
// ✅ Good: Selective subscription
const tasks = useAgentsStore((state) => state.tasks)

// ❌ Bad: Subscribe to entire store
const store = useAgentsStore()
```

### 5. Real-Time Updates via Tauri Events

Backend → Frontend real-time communication uses Tauri events for immediate UI updates without polling.

**Key Events:**
- `activity-created` - New activity added to database
- `activity-updated` - Activity modified
- `activity-deleted` - Activity removed
- `agent-task-update` - Task status changed
- `friendly-chat-trigger` - Live2D chat initiated

**Frontend Usage (Listening):**
```typescript
import { listen } from '@tauri-apps/api/event'

useEffect(() => {
  const unlisten = listen('activity-created', (event) => {
    // event.payload contains the activity data
    updateActivityStore(event.payload)
  })
  return () => unlisten.then((fn) => fn())
}, [])
```

**Backend Usage (Emitting):**
```python
# backend/core/events.py
from backend.core.events import emit_tauri_event

# Emit event to all frontend listeners
emit_tauri_event('activity-created', {
    'id': activity.id,
    'name': activity.name,
    'timestamp': activity.start_time.isoformat()
})
```

**Best Practices:**
- Always cleanup event listeners in useEffect return
- Debounce rapid events (e.g., activity updates) to avoid UI thrashing
- Use TypeScript types for event payloads to maintain type safety

## Activity Timeline Data Synchronization

The activity timeline uses a **version-based incremental update system** combined with **Tauri events**:

**Update Mechanism:**
1. **Initial Load**: `fetchActivityTimeline()` loads paginated data from database
2. **Incremental Updates**: `fetchActivitiesIncremental()` fetches new activities by version number
3. **Real-Time Events**: Tauri events (`activity-created`, `activity-updated`, `activity-deleted`) trigger updates

**Key Components:**
- `useActivityIncremental()` - Hook for incremental updates (sliding window strategy)
- `useInfiniteScroll()` - Bidirectional infinite scrolling with Intersection Observer
- `Activity/index.tsx` - Timeline view with event debouncing

**Important Implementation Details:**
1. **Event Debouncing**: Activity updates/deletes are debounced (300ms) to batch events
2. **Incremental Updates**: New activities merged at top with deduplication by date
3. **Safe Date Handling**: All timestamps validated to prevent "Invalid time value" errors
4. **Data Consistency**: Complete field mapping from backend to frontend

**Backend → Frontend Conversions:**
- `startTime` (ISO string) → `timestamp` (milliseconds)
- `sourceEvents` → `eventSummaries` with nested `events` array
- `activity.description` → `activity.name` (for display)
- `endTime` fallback to `startTime` if missing

## Internationalization (i18n)

TypeScript-first i18n with automatic type safety:

- **Translation files**: `src/locales/{en.ts, zh-CN.ts}`
- **English file** (`en.ts`) is the source of truth and defines TypeScript types
- **Type checking**: Prevents using non-existent translation keys at compile time
- **Validation**: Run `pnpm check-i18n` to ensure consistency

**Adding Translations:**
1. Add keys to `src/locales/en.ts` (always add to English first)
2. Add corresponding keys to `src/locales/zh-CN.ts` with same structure
3. Run `pnpm check-i18n` to validate
4. Use in components: `const { t } = useTranslation(); t('myFeature.title')`

See `docs/i18n.md` for detailed documentation.

## Common Development Tasks

### Adding a New Page

1. Create view component: `src/views/NewFeature/index.tsx`
2. Add menu item: `src/lib/config/menu.ts`
3. Add route with lazy loading: `src/routes/Index.tsx`
   ```typescript
   const NewFeatureView = lazy(() => import('@/views/NewFeature'))
   ```
4. Create store (if needed): `src/lib/stores/newFeature.ts`
5. Create service layer: `src/lib/services/newFeature/index.ts`

### Adding a New Agent

1. Extend `BaseAgent` in Python backend
2. Implement `execute()` and `can_handle()` methods
3. Register in `AgentFactory`
4. Update `AgentType` enum in `src/lib/types/agents.ts`
5. Add UI configuration in Agents view

### Testing Backend APIs

```bash
# Start standalone FastAPI server
uvicorn app:app --reload

# Access Swagger UI
# http://localhost:8000/docs

# Test endpoints with auto-generated documentation
```

## Testing

### Backend Testing

```bash
# Test specific Python modules
cd backend
python -m pytest tests/

# Test LLM integration
python scripts/test_llm.py

# Test perception layer (keyboard/mouse monitoring)
python scripts/test_perception_factory.py

# Test full processing pipeline
python scripts/test_full_pipeline.py

# Test image optimization
python scripts/test_image_optimization.py

# Test activity processing
python scripts/test_activity_processing.py
```

### Frontend Testing

```bash
# Type checking (catches TypeScript errors)
pnpm build  # or tsc --noEmit

# Lint checking
pnpm lint

# i18n validation (ensures translation consistency)
pnpm check-i18n
```

### Integration Testing

```bash
# Method 1: FastAPI standalone testing
uvicorn app:app --reload
# Then test endpoints at http://localhost:8000/docs

# Method 2: Full Tauri app testing
pnpm tauri:dev:gen-ts
# Verify PyTauri client generation and API calls work correctly

# Method 3: Frontend only (with mock data)
pnpm dev
# Test UI components without backend
```

## File Structure Conventions

### Do Not Edit (Auto-Generated)

- `src/lib/client/` - Auto-generated PyTauri client code
- `src/components/shadcn-ui/` - Generated shadcn/ui components (edit via CLI only)
- `src/types/auto-imports.d.ts` - Auto-generated types

### Key Directories

- `src/views/` - Page-level components (route targets)
- `src/layouts/` - Layout wrappers (MainLayout, AuthLayout)
- `src/lib/stores/` - Zustand state management
- `src/lib/services/` - API service layer (wraps PyTauri client)
- `src/lib/types/` - TypeScript type definitions
- `src/lib/config/` - Configuration files (menu, constants)
- `src/components/` - Reusable components organized by feature
- `src/hooks/` - Custom React hooks
- `backend/` - Python backend code (symlinked to `src-tauri/python/`)
- `backend/handlers/` - API handlers using `@api_handler` decorator
- `backend/models/` - Pydantic data models

### Naming Conventions

- **Components**: PascalCase (`ActivityTimeline`)
- **Hooks**: camelCase with `use` prefix (`useActivityStore`)
- **Types**: PascalCase (`Activity`, `AgentTask`)
- **Constants**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`)
- **Python Functions**: snake_case (auto-converts to camelCase for TypeScript)

## Defensive Programming Patterns

### Date/Timestamp Validation

```typescript
// ✅ Safe date parsing with fallback
const parseDate = (dateStr: string | undefined | null): number => {
  if (!dateStr) return Date.now()
  const parsed = new Date(dateStr).getTime()
  return isNaN(parsed) ? Date.now() : parsed
}
```

### Optional Property Access

```typescript
// ✅ Always use optional chaining for potentially undefined fields
{activity.eventSummaries?.length ?? 0}
{(activity.eventSummaries ?? []).map(...)}
```

### Loading State Awareness

- Check `loading || isRefreshing || loadingMore` before showing empty states
- Show loading indicator when data is loading, empty state only when truly empty

## Common Pitfalls

### Pitfall 1: Modifying Auto-Generated Files

**Problem:** Editing files that are automatically generated will cause your changes to be overwritten.

**Files to NEVER manually edit:**
- ❌ `src/lib/client/` - Auto-generated PyTauri TypeScript client
- ❌ `src/components/ui/` - shadcn/ui components (use CLI to modify)
- ❌ `src/types/auto-imports.d.ts` - Auto-generated type definitions

**Solution:** Always modify the source (Python handlers or use shadcn CLI for UI components).

### Pitfall 2: Forgetting to Import Handler Modules

**Problem:** Created a new handler but it doesn't appear in TypeScript client or FastAPI docs.

**Solution:** Always import new handler modules in `backend/handlers/__init__.py`:

```python
# backend/handlers/__init__.py
from . import (
    greeting,
    perception,
    processing,
    system,
    agents,
    chat,
    my_new_handler,  # ← ADD THIS LINE
)
```

Then run: `pnpm setup-backend && pnpm tauri dev`

### Pitfall 3: Incorrect Python Environment Location

**Problem:** Running `uv sync` or installing packages in wrong directory.

**Critical:** Python environment is at **PROJECT ROOT**, not `src-tauri/`!

```
✅ Correct:
Rewind/.venv/                  ← Python environment HERE
Rewind/pyproject.toml          ← Python config HERE

❌ Wrong:
Rewind/src-tauri/.venv/        ← DON'T create here
```

**Solution:** Always run `pnpm setup-backend` from project root.

### Pitfall 4: Date Handling Errors

**Problem:** "Invalid time value" errors when parsing dates from backend.

**Solution:** Always validate dates before using:

```typescript
// ❌ Bad: Can throw "Invalid time value"
const timestamp = new Date(activity.startTime).getTime()

// ✅ Good: Safe with fallback
const parseDate = (dateStr: string | undefined | null): number => {
  if (!dateStr) return Date.now()
  const parsed = new Date(dateStr).getTime()
  return isNaN(parsed) ? Date.now() : parsed
}
const timestamp = parseDate(activity.startTime)
```

### Pitfall 5: Windows Line Endings

**Problem:** Git shows many files as modified with no actual changes, or merge conflicts with line endings.

**Solution:** On Windows, always configure git immediately after cloning:

```bash
git config core.autocrlf false
```

**Why:** Windows uses CRLF (`\r\n`) while Unix uses LF (`\n`). This setting prevents automatic conversion that causes issues in cross-platform development.

### Pitfall 6: PyTauri Handler Parameter Constraints

**Problem:** PyTauri handler fails with parameter errors.

**Critical Constraint:** PyTauri handlers MUST use either:
- No parameters, OR
- A single `body` parameter with a Pydantic model

```python
# ❌ Wrong: Multiple parameters
@api_handler()
async def my_handler(arg1: str, arg2: int):
    pass

# ❌ Wrong: Direct primitive parameter
@api_handler()
async def my_handler(name: str):
    pass

# ✅ Correct: No parameters
@api_handler()
async def my_handler() -> dict:
    return {"status": "ok"}

# ✅ Correct: Single body parameter
@api_handler(body=MyRequest)
async def my_handler(body: MyRequest) -> dict:
    return {"data": body.field1}
```

### Pitfall 7: Zustand Store Subscriptions

**Problem:** Component re-renders excessively, causing performance issues.

**Solution:** Use selective subscriptions, not entire store:

```typescript
// ❌ Bad: Subscribes to entire store, re-renders on any change
const store = useActivityStore()

// ✅ Good: Only subscribes to specific state
const activities = useActivityStore((state) => state.activities)
const isLoading = useActivityStore((state) => state.loading)
```

## Performance Considerations

- **Lazy Loading**: All route components use React.lazy for code splitting
- **Virtual Scrolling**: Used for long lists (activity timeline)
- **Memoization**: Apply React.memo to pure presentational components
- **Store Subscriptions**: Always use selectors to minimize re-renders
- **Image Optimization**: Backend compresses screenshots and uses perceptual hashing for deduplication
- **Batch Processing**: Backend processes events every 10 seconds to reduce LLM calls

## Important Files and Documentation

**Core Documentation** (start here for detailed information):
- `docs/development.md` - Complete setup and development workflow guide
- `docs/architecture.md` - System architecture overview
- `docs/frontend.md` - Frontend architecture documentation
- `docs/backend.md` - Backend system design documentation
- `docs/api_handler.md` - Universal API handler system documentation
- `docs/i18n.md` - Internationalization configuration
- `docs/fastapi_usage.md` - FastAPI standalone server usage
- `docs/python_environment.md` - Python environment management

**Frontend Key Files:**
- `src/lib/config/menu.ts` - Menu configuration (affects routing and UI)
- `src/routes/Index.tsx` - Application routing definition
- `src/lib/stores/` - Zustand state management stores
- `src/lib/client/` - Auto-generated PyTauri TypeScript client (DO NOT EDIT)

**Backend Key Files:**
- `app.py` - FastAPI application entry point (standalone server)
- `backend/handlers/__init__.py` - Universal API handler decorator and registration
- `backend/handlers/{greeting,perception,processing,system,agents}.py` - API handler modules
- `backend/models/base.py` - Pydantic BaseModel with camelCase conversion
- `backend/models/requests.py` - Request model definitions
- `src-tauri/python/rewind_app/__init__.py` - PyTauri command registration entry point

**Configuration:**
- `pyproject.toml` - Python project configuration (at project root)
- `package.json` - Node.js dependencies and scripts
- `src-tauri/Cargo.toml` - Rust dependencies including PyTauri
- `src-tauri/src/lib.rs` - Rust-Python bridge configuration

## Special Notes

### ⚠️ CRITICAL: Python Environment Location

**THE PYTHON VIRTUAL ENVIRONMENT IS AT THE PROJECT ROOT, NOT IN `src-tauri/`!**

```
✅ Correct Structure:
Rewind/
├── .venv/              ← Python virtual environment HERE
├── pyproject.toml      ← Python configuration HERE
├── src/                ← Frontend code
├── src-tauri/
│   ├── python/        ← Python source code here
│   └── Cargo.toml
└── backend/           ← Symlink to src-tauri/python (or actual code)
```

**Critical Commands:**
- `pnpm setup-backend` - Re-sync Python environment at **project root**
- `uv sync` - Install Python packages (run from **project root**)
- After ANY Python changes: `pnpm setup-backend && pnpm tauri dev`

**Why This Matters:**
- PyTauri needs to find the .venv at project root during build
- Running `uv sync` in wrong directory creates invalid environment
- Wrong environment location causes cryptic build errors

### Other Important Notes

- **TypeScript Strict Mode**: Project uses strict TypeScript settings
- **Path Aliases**: Use `@/*` for imports from `src/`
- **Theme System**: next-themes provider for light/dark mode
- **Form Validation**: Use React Hook Form + Zod schema validation
- **Error Boundaries**: Wrap major sections for graceful error handling
- **Activity Timeline UI**: Maintains consistent styling across items with subtle entrance animations
- **Windows Development**: Always run `git config core.autocrlf false` to prevent line ending issues

## Data Models (Backend)

- `RawRecord` - Raw input events (timestamp, type, data)
- `Event` - Filtered and summarized events
- `Activity` - Grouped related events with LLM-generated description
- `Task` - Agent tasks with execution state (todo/doing/done/cancelled)

## Agent System Architecture

- **Factory Pattern**: `AgentFactory` for extensible agents
- **Base Class**: `BaseAgent` with `execute()` and `can_handle()` methods
- **Task States**: `todo`, `doing`, `done`, `cancelled`
- **Parallel Execution**: Supports running multiple agents concurrently

## Live2D Integration

The application includes a Live2D mascot feature with interactive chat capabilities:

**Key Components:**
- `backend/handlers/live2d.py` - Live2D model configuration and state management
- `backend/handlers/friendly_chat.py` - Scheduled friendly chat interactions with the user
- `backend/services/friendly_chat_service.py` - Chat service implementation
- Frontend uses `pixi-live2d-display` library (PixiJS 6.5.6) for rendering

**Features:**
- Live2D character displays in sidebar/floating panel
- Automatic friendly chat triggers based on timers or events
- Hover interactions and state changes
- Customizable models and expressions

**Adding/Modifying Live2D Models:**
1. Place model files in appropriate directory
2. Update configuration via `live2d.py` handlers
3. Frontend components will automatically load new models

**Event Flow:**
```
Timer/User Action → friendly_chat_service.py
    ↓
Emit 'friendly-chat-trigger' event
    ↓
Frontend receives event → Display chat message
    ↓
Live2D model shows animation/expression
```

## System Permissions

The application requires specific OS permissions to capture user activity:

### Required Permissions

**macOS:**
- **Screen Recording** - Required for screenshot capture
- **Accessibility** - Required for keyboard and mouse monitoring
- **Input Monitoring** - Required for detailed event capture

**Windows:**
- **Input Monitoring** - For keyboard/mouse event capture
- **Screen Capture** - For screenshot functionality

**Linux:**
- **X11/Wayland Access** - For event monitoring
- **Screen Capture** - For screenshot functionality

### Permission Handling

**Backend Implementation:**
- `backend/system/permissions.py` - Permission checking and requesting logic
- `backend/handlers/permissions.py` - API handlers for permission status
- Platform-specific permission requests via PyObjC (macOS) or native APIs

**Frontend Integration:**
- Permission checks happen at app startup via `useBackendLifecycle()` hook
- Users are prompted to grant permissions if missing
- Permission status displayed in system status indicator
- Graceful degradation if permissions are denied

**Checking Permissions:**
```python
# Backend
from backend.system.permissions import check_permissions, request_permissions

status = await check_permissions()
if not status.all_granted:
    await request_permissions()
```

```typescript
// Frontend
import { checkPermissions } from '@/lib/client'

const status = await checkPermissions()
if (!status.allGranted) {
  // Show permission prompt UI
}
```

**Important Notes:**
- App functionality is limited without proper permissions
- Permission requests may require app restart on some platforms
- See `docs/PERMISSIONS_*.md` for detailed implementation guides
