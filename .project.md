# Rule

This file provides guidance to LLM when working with code in this repository.

## Project Overview

Rewind is a Tauri-based desktop application that monitors and analyzes user activity (keyboard, mouse, screenshots) using AI to provide intelligent insights and task recommendations. It features a three-layer architecture:

1. **Perception Layer** - Captures raw user input (keyboard, mouse, screenshots)
2. **Processing Layer** - Filters, summarizes, and organizes events using LLM
3. **Consumption Layer** - Provides intelligent analysis and agent-based task execution

## Technology Stack

### Frontend

- **Framework**: React 19 + TypeScript 5
- **Build Tool**: Vite 6
- **Routing**: React Router 7
- **State Management**: Zustand 5 (with persist middleware)
- **UI Components**: shadcn/ui (Radix UI primitives)
- **Styling**: Tailwind CSS 4
- **Forms**: React Hook Form + Zod
- **Date Handling**: date-fns
- **Notifications**: Sonner

### Backend

- **Runtime**: Tauri 2.x (Rust)
- **Python Backend**: PyTauri 0.8 (Python ↔ Rust bridge)
- **Database**: SQLite
- **LLM Integration**: OpenAI API (configurable)
- **Image Processing**: OpenCV, PIL
- **System Monitoring**:
  - **Keyboard/Mouse**: Platform-specific implementations (factory pattern)
    - macOS: PyObjC NSEvent (keyboard), pynput (mouse)
    - Windows: pynput (extensible to Win32 API)
    - Linux: pynput (extensible to X11/evdev)
  - **Screenshots**: mss (cross-platform)

## Development Commands

### Initial Setup

Run one of these commands from the project root to initialize everything:

```bash
# macOS / Linux (recommended)
pnpm setup

# Windows
pnpm setup:win

# Or manually run all steps
pnpm setup-all
```

This automatically:
1. Installs frontend dependencies (`pnpm install`)
2. Initializes Python environment (`uv sync` - creates `.venv` in project root)
3. Verifies i18n translations (`pnpm check-i18n`)

**Critical**: Python environment is at **project root**, not `src-tauri/`. The `pyproject.toml` is at the project root.

### Common Development Workflows

**Frontend-only development** (fastest iteration):
```bash
pnpm dev  # http://localhost:5173
```

**Full application development** (with backend):
```bash
pnpm tauri:dev:gen-ts  # Recommended - auto-generates TypeScript client
# OR
pnpm tauri dev  # Without regenerating client
```

**Backend API development** (standalone FastAPI):
```bash
uvicorn app:app --reload  # http://localhost:8000/docs
# OR
uv run python app.py
```

**After adding Python modules or dependencies**:
```bash
pnpm setup-backend  # Re-sync Python environment
pnpm tauri dev      # Regenerate TypeScript client
```

### Code Quality

```bash
pnpm format          # Format code (Prettier)
pnpm lint            # Check formatting (CI)
pnpm check-i18n      # Validate translation keys
pnpm build           # Build TypeScript and frontend
pnpm tauri build     # Build production app
pnpm clean           # Clean build artifacts
```

## Architecture Guidelines

### Three-Layer Backend Architecture

```
┌──────────────────────────────────────────────────────────┐
│              Consumption Layer (消费层)                  │
│              AI 分析 → 智能推荐 → Agent 执行            │
└──────────────────────────────────────────────────────────┘
                          ▲
┌──────────────────────────────────────────────────────────┐
│              Processing Layer (处理层)                   │
│       事件筛选 → LLM总结 → 活动合并 → 数据库存储        │
└──────────────────────────────────────────────────────────┘
                          ▲
┌──────────────────────────────────────────────────────────┐
│              Perception Layer (感知层)                   │
│         键盘监控 → 鼠标监控 → 屏幕截图采集              │
└──────────────────────────────────────────────────────────┘
```

**Data Flow:**
```
Raw Records (20s sliding window)
    ↓ [Every 10s]
Events (with events_summary)
    ↓ [LLM summarization + activity merging]
Activity (persisted to SQLite)
    ↓ [Intelligent analysis]
Agent Tasks → TODO
```

### Frontend Architecture

**Component Hierarchy:**
```
Pages (src/views/)                    # Data fetching, state management
  ├─ Containers (src/components/)     # Business logic, composition
  │   └─ Components                   # Pure presentation
  │       └─ Primitives (shadcn-ui)   # Base UI components
```

**State Management Strategy:**
- **Zustand Stores** (`src/lib/stores/`) for cross-component state
  - `activity.ts` - Timeline data and filters
  - `agents.ts` - Agent tasks and execution state
  - `chat.ts` - Chat conversation state
  - `dashboard.ts` - Metrics and statistics
  - `insights.ts` - AI insights data
  - `models.ts` - LLM model configuration
  - `settings.ts` - Application settings
  - `ui.ts` - UI state (sidebar, menu selection)
  - `user.ts` - User profile and preferences
- **Props/Callbacks** for parent-child communication
- **Context** for theme and global configuration
- **Tauri Events** for backend → frontend real-time updates

**Communication Pattern:**
```
User Action → Component Handler → Zustand Action → Service Layer → PyTauri Client → Backend
                                                                                      ↓
Frontend Component ← Zustand Store Update ← Response/Tauri Event ←←←←←←←←←←←←←←←←←←←←←
```

### Universal API Handler System

The project uses a **universal `@api_handler` decorator** that automatically registers backend functions for **both PyTauri and FastAPI** frameworks.

**Adding a New API Handler:**

1. Create handler in `backend/handlers/my_module.py`:
   ```python
   from . import api_handler
   from models import MyRequest

   @api_handler(
       body=MyRequest,           # Pydantic model (optional if no params)
       method="POST",            # HTTP method (for FastAPI)
       path="/my-endpoint",      # Custom path (for FastAPI)
       tags=["my-module"]        # API tags (for FastAPI docs)
   )
   async def my_handler(body: MyRequest) -> dict:
       """Handler description (auto-converted to API docs)"""
       return {"success": True, "data": body.field1}
   ```

2. Add Request Model in `backend/models/requests.py`:
   ```python
   from .base import BaseModel

   class MyRequest(BaseModel):
       """Request model inherits camelCase conversion"""
       field1: str
       field2: int = 100  # With default
   ```

3. Import module in `backend/handlers/__init__.py`:
   ```python
   from . import greeting, perception, processing, my_module
   ```

4. Regenerate TypeScript client and test:
   ```bash
   pnpm tauri:dev:gen-ts
   ```

**Key Features:**
- **Single Definition**: Works for both PyTauri (desktop) and FastAPI (web API)
- **Auto-Registration**: No manual command registration needed
- **Type Safety**: Pydantic models auto-generate TypeScript types
- **CamelCase Conversion**: Python `snake_case` ↔ JavaScript `camelCase` automatic
- **API Documentation**: FastAPI auto-generates OpenAPI/Swagger docs at `/docs`

**Critical Constraint**: PyTauri handlers MUST use a single `body` parameter with a Pydantic model. Direct parameters like `def handler(name: str)` will fail.

## Key Design Patterns

### 1. Configuration-Driven Menu

Menu items in `src/lib/config/menu.ts` drive both routing and sidebar UI:
- Supports position grouping (main/bottom)
- Badge notifications
- Dynamic visibility control

### 2. PyTauri Client Auto-Generation

- Backend changes trigger automatic TypeScript client generation
- Located in `src/lib/client/` (marked as auto-generated)
- **Never manually edit client files**

### 3. Service Layer Pattern

Services in `src/lib/services/` wrap PyTauri client calls:
- Handles error logging and retry logic
- Used by Zustand store actions
- Provides clean API abstraction

### 4. Store Subscription Optimization

```typescript
// ✅ Good: Selective subscription
const tasks = useAgentsStore((state) => state.tasks)

// ❌ Bad: Subscribe to entire store
const store = useAgentsStore()
```

### 5. Real-Time Updates via Tauri Events

```typescript
import { listen } from '@tauri-apps/api/event'

useEffect(() => {
  const unlisten = listen('agent-task-update', (event) => {
    updateTaskStatus(event.payload)
  })
  return () => unlisten.then((fn) => fn())
}, [])
```

## Activity Timeline Data Synchronization

The activity timeline uses a **version-based incremental update system** combined with **Tauri events**:

**Update Mechanism:**
1. **Initial Load**: `fetchActivityTimeline()` loads paginated data from database
2. **Incremental Updates**: `fetchActivitiesIncremental()` fetches new activities by version number
3. **Real-Time Events**: Tauri events (`activity-created`, `activity-updated`, `activity-deleted`) trigger updates

**Key Components:**
- `useActivityIncremental()` - Hook for incremental updates (sliding window strategy)
- `useInfiniteScroll()` - Bidirectional infinite scrolling with Intersection Observer
- `Activity/index.tsx` - Timeline view with event debouncing

**Important Implementation Details:**
1. **Event Debouncing**: Activity updates/deletes are debounced (300ms) to batch events
2. **Incremental Updates**: New activities merged at top with deduplication by date
3. **Safe Date Handling**: All timestamps validated to prevent "Invalid time value" errors
4. **Data Consistency**: Complete field mapping from backend to frontend

**Backend → Frontend Conversions:**
- `startTime` (ISO string) → `timestamp` (milliseconds)
- `sourceEvents` → `eventSummaries` with nested `events` array
- `activity.description` → `activity.name` (for display)
- `endTime` fallback to `startTime` if missing

## Internationalization (i18n)

TypeScript-first i18n with automatic type safety:

- **Translation files**: `src/locales/{en.ts, zh-CN.ts}`
- **English file** (`en.ts`) is the source of truth and defines TypeScript types
- **Type checking**: Prevents using non-existent translation keys at compile time
- **Validation**: Run `pnpm check-i18n` to ensure consistency

**Adding Translations:**
1. Add keys to `src/locales/en.ts` (always add to English first)
2. Add corresponding keys to `src/locales/zh-CN.ts` with same structure
3. Run `pnpm check-i18n` to validate
4. Use in components: `const { t } = useTranslation(); t('myFeature.title')`

See `docs/i18n.md` for detailed documentation.

## Common Development Tasks

### Adding a New Page

1. Create view component: `src/views/NewFeature/index.tsx`
2. Add menu item: `src/lib/config/menu.ts`
3. Add route with lazy loading: `src/routes/Index.tsx`
   ```typescript
   const NewFeatureView = lazy(() => import('@/views/NewFeature'))
   ```
4. Create store (if needed): `src/lib/stores/newFeature.ts`
5. Create service layer: `src/lib/services/newFeature/index.ts`

### Adding a New Agent

1. Extend `BaseAgent` in Python backend
2. Implement `execute()` and `can_handle()` methods
3. Register in `AgentFactory`
4. Update `AgentType` enum in `src/lib/types/agents.ts`
5. Add UI configuration in Agents view

### Testing Backend APIs

```bash
# Start standalone FastAPI server
uvicorn app:app --reload

# Access Swagger UI
# http://localhost:8000/docs

# Test endpoints with auto-generated documentation
```

## File Structure Conventions

### Do Not Edit (Auto-Generated)

- `src/lib/client/` - Auto-generated PyTauri client code
- `src/components/shadcn-ui/` - Generated shadcn/ui components (edit via CLI only)
- `src/types/auto-imports.d.ts` - Auto-generated types

### Key Directories

- `src/views/` - Page-level components (route targets)
- `src/layouts/` - Layout wrappers (MainLayout, AuthLayout)
- `src/lib/stores/` - Zustand state management
- `src/lib/services/` - API service layer (wraps PyTauri client)
- `src/lib/types/` - TypeScript type definitions
- `src/lib/config/` - Configuration files (menu, constants)
- `src/components/` - Reusable components organized by feature
- `src/hooks/` - Custom React hooks
- `backend/` - Python backend code (symlinked to `src-tauri/python/`)
- `backend/handlers/` - API handlers using `@api_handler` decorator
- `backend/models/` - Pydantic data models

### Naming Conventions

- **Components**: PascalCase (`ActivityTimeline`)
- **Hooks**: camelCase with `use` prefix (`useActivityStore`)
- **Types**: PascalCase (`Activity`, `AgentTask`)
- **Constants**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`)
- **Python Functions**: snake_case (auto-converts to camelCase for TypeScript)

## Defensive Programming Patterns

### Date/Timestamp Validation

```typescript
// ✅ Safe date parsing with fallback
const parseDate = (dateStr: string | undefined | null): number => {
  if (!dateStr) return Date.now()
  const parsed = new Date(dateStr).getTime()
  return isNaN(parsed) ? Date.now() : parsed
}
```

### Optional Property Access

```typescript
// ✅ Always use optional chaining for potentially undefined fields
{activity.eventSummaries?.length ?? 0}
{(activity.eventSummaries ?? []).map(...)}
```

### Loading State Awareness

- Check `loading || isRefreshing || loadingMore` before showing empty states
- Show loading indicator when data is loading, empty state only when truly empty

## Performance Considerations

- **Lazy Loading**: All route components use React.lazy for code splitting
- **Virtual Scrolling**: Used for long lists (activity timeline)
- **Memoization**: Apply React.memo to pure presentational components
- **Store Subscriptions**: Always use selectors to minimize re-renders
- **Image Optimization**: Backend compresses screenshots and uses perceptual hashing for deduplication
- **Batch Processing**: Backend processes events every 10 seconds to reduce LLM calls

## Important Files and Documentation

**Core Documentation** (start here for detailed information):
- `docs/development.md` - Complete setup and development workflow guide
- `docs/architecture.md` - System architecture overview
- `docs/frontend.md` - Frontend architecture documentation
- `docs/backend.md` - Backend system design documentation
- `docs/api_handler.md` - Universal API handler system documentation
- `docs/i18n.md` - Internationalization configuration
- `docs/fastapi_usage.md` - FastAPI standalone server usage
- `docs/python_environment.md` - Python environment management

**Frontend Key Files:**
- `src/lib/config/menu.ts` - Menu configuration (affects routing and UI)
- `src/routes/Index.tsx` - Application routing definition
- `src/lib/stores/` - Zustand state management stores
- `src/lib/client/` - Auto-generated PyTauri TypeScript client (DO NOT EDIT)

**Backend Key Files:**
- `app.py` - FastAPI application entry point (standalone server)
- `backend/handlers/__init__.py` - Universal API handler decorator and registration
- `backend/handlers/{greeting,perception,processing,system,agents}.py` - API handler modules
- `backend/models/base.py` - Pydantic BaseModel with camelCase conversion
- `backend/models/requests.py` - Request model definitions
- `src-tauri/python/rewind_app/__init__.py` - PyTauri command registration entry point

**Configuration:**
- `pyproject.toml` - Python project configuration (at project root)
- `package.json` - Node.js dependencies and scripts
- `src-tauri/Cargo.toml` - Rust dependencies including PyTauri
- `src-tauri/src/lib.rs` - Rust-Python bridge configuration

## Special Notes

- **TypeScript Strict Mode**: Project uses strict TypeScript settings
- **Path Aliases**: Use `@/*` for imports from `src/`
- **Theme System**: next-themes provider for light/dark mode
- **Form Validation**: Use React Hook Form + Zod schema validation
- **Error Boundaries**: Wrap major sections for graceful error handling
- **Python Environment Location**: `.venv` is at **project root**, not in `src-tauri/`
- **After Python Changes**: Must run `pnpm setup-backend` before `pnpm tauri dev`
- **Activity Timeline UI**: Maintains consistent styling across items with subtle entrance animations

## Data Models (Backend)

- `RawRecord` - Raw input events (timestamp, type, data)
- `Event` - Filtered and summarized events
- `Activity` - Grouped related events with LLM-generated description
- `Task` - Agent tasks with execution state (todo/doing/done/cancelled)

## Agent System Architecture

- **Factory Pattern**: `AgentFactory` for extensible agents
- **Base Class**: `BaseAgent` with `execute()` and `can_handle()` methods
- **Task States**: `todo`, `doing`, `done`, `cancelled`
- **Parallel Execution**: Supports running multiple agents concurrently
